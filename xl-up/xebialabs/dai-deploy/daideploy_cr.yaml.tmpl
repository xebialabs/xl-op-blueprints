apiVersion: xld.my.domain/v1alpha1
kind: XlDeployHelmcharts
metadata:
  name: xldeploy
spec:
  AdminPassword: {{ .AdminPassword }}
  HealthPeriodScans: 10
  HealthProbeFailureThreshold: 12
  HealthProbes: true
  HealthProbesLivenessTimeout: 90
  HealthProbesReadinessTimeout: 90
  ImagePullPolicy: Always
  ImageRepository: {{ .ImageRepositoryDeploy }}
  ImageTag: {{ .ImageTag }}
#  ImagePullSecret: regcred-xl
  K8sSetup:
    Platform: {{ .K8sSetup }}
  KeystorePassphrase: {{ .KeyStorePass }}
  Persistence:
    AccessMode: ReadWriteOnce
    Annotations: {}
    Enabled: true
    StorageClass: {{ .StorageClass }}
    XldExportPvcSize: 10Gi
    XldWorkPvcSize: 5Gi
  RepositoryKeystore: {{ .KeyStore | b64enc }}
  {{- if .UseExistingDB }}
  UseExistingDB:
    Enabled: true
    XL_DB_PASSWORD: {{ .XLDBPassword }}
    XL_DB_URL: {{ .XLDBURL }}
    XL_DB_USERNAME: {{ .XLDBUserName }}
  {{- else }}
  UseExistingDB:
    Enabled: false
  {{- end }}
  {{- if .UseExistingMQ }}
  UseExistingMQ:
    Enabled: true
    XLD_TASK_QUEUE_DRIVER_CLASS_NAME: {{ .XLDTaskQueueDriverClassName }}
    XLD_TASK_QUEUE_PASSWORD: {{ .XLDTaskQueuePassword }}
    XLD_TASK_QUEUE_URL: {{ .XLDTaskQueueURL }}
    XLD_TASK_QUEUE_USERNAME: {{ .XLDTaskQueueUsername }}
  {{- else }}
  UseExistingMQ:
    Enabled: false
  {{- end }}
  XldMasterCount: {{ .MasterCount }}
  XldWorkerCount: {{ .WorkerCount }}
  affinity: {}
  haproxy-ingress:
    controller:
      affinity: {}
      autoscaling:
        customMetrics: []
        enabled: false
      config: {}
      daemonset:
        hostPorts:
          http: 80
          https: 443
          tcp: []
        useHostPort: false
      defaultBackendService: ''
      dnsPolicy: ClusterFirst
      enableStaticPorts: true
      extraArgs: {}
      extraEnvs: []
      healthzPort: 10253
      hostNetwork: false
      image:
        pullPolicy: IfNotPresent
        repository: quay.io/jcmoraisjr/haproxy-ingress
        tag: v0.9.2
      imagePullSecrets: []
      ingressClass: haproxy
      initContainers: []
      kind: DaemonSet
      livenessProbe:
        failureThreshold: 3
        initialDelaySeconds: 10
        path: /healthz
        periodSeconds: 10
        port: 10253
        successThreshold: 1
        timeoutSeconds: 1
      logs:
        enabled: false
        image:
          pullPolicy: IfNotPresent
          repository: whereisaaron/kube-syslog-sidecar
          tag: latest
        resources: {}
      metrics:
        enabled: false
        extraArgs: {}
        image:
          pullPolicy: IfNotPresent
          repository: quay.io/prometheus/haproxy-exporter
          tag: v0.10.0
        resources: {}
        service:
          annotations: {}
          clusterIP: ''
          externalIPs: []
          loadBalancerIP: ''
          loadBalancerSourceRanges: []
          servicePort: 9101
          type: ClusterIP
      minAvailable: 1
      minReadySeconds: 0
      nodeSelector: {}
      podAffinity: {}
      podAnnotations: {}
      podLabels: {}
      priorityClassName: ''
      readinessProbe:
        failureThreshold: 3
        initialDelaySeconds: 10
        path: /healthz
        periodSeconds: 10
        port: 10253
        successThreshold: 1
        timeoutSeconds: 1
      replicaCount: 1
      resources: {}
      securityContext: {}
      service:
        annotations: {}
        clusterIP: ''
        externalIPs: []
        externalTrafficPolicy: Local
        healthCheckNodePort: 0
        httpPorts:
        - port: 80
          targetPort: http
        httpsPorts:
        - port: 443
          targetPort: https
        labels: {}
        loadBalancerIP: ''
        loadBalancerSourceRanges: []
        type: LoadBalancer
      stats:
        enabled: false
        port: 1936
        service:
          annotations: {}
          clusterIP: ''
          externalIPs: []
          loadBalancerIP: ''
          loadBalancerSourceRanges: []
          servicePort: 1936
          type: ClusterIP
      tcp: {}
      template: ''
      terminationGracePeriodSeconds: 60
      tolerations: []
      updateStrategy:
        rollingUpdate:
          maxUnavailable: 1
        type: RollingUpdate
    defaultBackend:
      affinity: {}
      enabled: false
      image:
        pullPolicy: IfNotPresent
        repository: gcr.io/google_containers/defaultbackend
        tag: '1.0'
      minAvailable: 1
      name: default-backend
      nodeSelector: {}
      podAnnotations: {}
      podLabels: {}
      replicaCount: 1
      resources:
        limits:
          cpu: 10m
          memory: 20Mi
      service:
        annotations: {}
        clusterIP: ''
        externalIPs: []
        loadBalancerIP: ''
        loadBalancerSourceRanges: []
        name: ingress-default-backend
        servicePort: 8080
        type: ClusterIP
      tolerations: []
    fullnameOverride: ''
    global: {}
    install: true
    nameOverride: ''
    rbac:
      create: true
      secret:
        write: false
      security:
        enable: false
    serviceAccount:
      create: true
  ingress:
    Enabled: true
    annotations:
      ingress.kubernetes.io/affinity: cookie
      ingress.kubernetes.io/config-backend: 'option httpchk GET /deployit/ha/health
        HTTP/1.0

        '
      ingress.kubernetes.io/rewrite-target: /
      ingress.kubernetes.io/session-cookie-name: SESSION_XLD
      ingress.kubernetes.io/session-cookie-strategy: prefix
      ingress.kubernetes.io/ssl-redirect: 'false'
      kubernetes.io/ingress.class: haproxy
    hosts:
    - {{ .IngressHost }}
    path: /xl-deploy/
  nodeSelector: {}
  postgresql:
    affinity: {}
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ''
      logTimezone: ''
      pgAuditLog: ''
      pgAuditLogCatalog: 'off'
    common:
      exampleValue: common-chart
      global:
        postgresql: {}
    commonAnnotations: {}
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    extraDeploy: []
    extraEnv: []
    global:
      postgresql: {}
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/postgresql
      tag: 11.9.0-debian-10-r48
    initdbScriptsSecret: postgresql-init-sql-xld
    install: {{ not .UseExistingDB}}
    ldap:
      baseDN: ''
      bindDN: ''
      enabled: false
      port: ''
      prefix: ''
      scheme: ''
      search_attr: ''
      search_filter: ''
      server: ''
      suffix: ''
      tls: false
      url: ''
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    master:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeSelector: {}
      podAnnotations: {}
      podLabels: {}
      priorityClassName: ''
      service: {}
      sidecars: []
      tolerations: []
    masterAsStandBy:
      enabled: false
    metrics:
      enabled: false
      extraEnvVars: {}
      image:
        pullPolicy: IfNotPresent
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.8.0-debian-10-r242
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ''
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      securityContext:
        enabled: false
        runAsUser: 1001
      service:
        annotations:
          prometheus.io/port: '9187'
          prometheus.io/scrape: 'true'
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
    networkPolicy:
      allowExternal: true
      enabled: false
      explicitNamespacesSelector: {}
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: null
      mountPath: /bitnami/postgresql
      size: 50Gi
      storageClass: {{ .StorageClass }}
      subPath: ''
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlDbUserConnectionLimit: null
    postgresqlExtendedConf:
      listenAddresses: '''*'''
      maxConnections: '500'
    postgresqlMaxConnections: null
    postgresqlPassword: postgres
    postgresqlPghbaRemoveFilters: null
    postgresqlPostgresConnectionLimit: null
    postgresqlSharedPreloadLibraries: pgaudit
    postgresqlStatementTimeout: null
    postgresqlTcpKeepalivesCount: null
    postgresqlTcpKeepalivesIdle: null
    postgresqlTcpKeepalivesInterval: null
    postgresqlUsername: postgres
    psp:
      create: false
    rbac:
      create: false
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replication:
      applicationName: my_application
      enabled: false
      numSynchronousReplicas: 0
      password: repl_password
      slaveReplicas: 1
      synchronousCommit: 'off'
      user: repl_user
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
    service:
      annotations: {}
      port: 5432
      type: ClusterIP
    serviceAccount:
      enabled: false
    shmVolume:
      chmod:
        enabled: true
      enabled: true
    slave:
      affinity: {}
      annotations: {}
      extraInitContainers: '# - name: do-something

        #   image: busybox

        #   command: [''do'', ''something'']

        '
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeSelector: {}
      persistence:
        enabled: true
      podAnnotations: {}
      podLabels: {}
      priorityClassName: ''
      resources: {}
      service: {}
      sidecars: []
      tolerations: []
    tls:
      certFilename: ''
      certKeyFilename: ''
      certificatesSecret: ''
      enabled: false
      preferServerCiphers: true
    tolerations: []
    updateStrategy:
      type: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        registry: docker.io
        repository: bitnami/minideb
        tag: buster
      securityContext:
        runAsUser: 0
  rabbitmq:
    advancedConfiguration: ''
    affinity: {}
    auth:
      erlangCookie: DEPLOYRABBITMQCLUSTER
      password: guest
      tls:
        caCertificate: ''
        enabled: false
        failIfNoPeerCert: true
        serverCertificate: ''
        serverKey: ''
        sslOptionsVerify: verify_peer
      username: guest
    clusterDomain: cluster.local
    clustering:
      addressType: hostname
      forceBoot: false
      rebalance: false
    common:
      exampleValue: common-chart
      global: {}
    configuration: '## Username and password

      default_user = {{`{{ .Values.auth.username }}`}}

      default_pass = CHANGEME

      ## Clustering

      cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s

      cluster_formation.k8s.host = kubernetes.default.svc.{{`{{ .Values.clusterDomain }}`}}

      cluster_formation.node_cleanup.interval = 10

      cluster_formation.node_cleanup.only_log_warning = true

      cluster_partition_handling = autoheal

      # queue master locator

      queue_master_locator = min-masters

      # enable guest user

      loopback_users.guest = false

      {{`{{ tpl .Values.extraConfiguration . }}`}}

      {{`{{- if .Values.auth.tls.enabled }}`}}

      ssl_options.verify = {{`{{ .Values.auth.tls.sslOptionsVerify }}`}}

      listeners.ssl.default = {{`{{ .Values.service.tlsPort }}`}}

      ssl_options.fail_if_no_peer_cert = {{`{{ .Values.auth.tls.failIfNoPeerCert }}`}}

      ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem

      ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem

      ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem

      {{`{{- end }}`}}

      {{`{{- if .Values.ldap.enabled }}`}}

      auth_backends.1 = rabbit_auth_backend_ldap

      auth_backends.2 = internal

      {{`{{- range $index, $server := .Values.ldap.servers }}`}}

      auth_ldap.servers.{{`{{ add $index 1 }}`}} = {{`{{ $server }}`}}

      {{`{{- end }}`}}

      auth_ldap.port = {{`{{ .Values.ldap.port }}`}}

      auth_ldap.user_dn_pattern = {{`{{ .Values.ldap.user_dn_pattern  }}`}}

      {{`{{- if .Values.ldap.tls.enabled }}`}}

      auth_ldap.use_ssl = true

      {{`{{- end }}`}}

      {{`{{- end }}`}}

      {{`{{- if .Values.metrics.enabled }}`}}

      ## Prometheus metrics

      prometheus.tcp.port = 9419

      {{`{{- end }}`}}

      {{`{{- if .Values.memoryHighWatermark.enabled }}`}}

      ## Memory Threshold

      total_memory_available_override_value = {{`{{ include "rabbitmq.toBytes" .Values.resources.limits.memory }}`}}

      vm_memory_high_watermark.{{`{{ .Values.memoryHighWatermark.type }}`}} = {{`{{ .Values.memoryHighWatermark.value }}`}}

      {{`{{- end }}`}}'
    containerSecurityContext: {}
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraConfiguration: "load_definitions = /app/xld-load_definition.json \n"
    extraContainerPorts: []
    extraEnvVars: []
    extraPlugins: rabbitmq_jms_topic_exchange
    extraSecrets:
      xld-load-definition:
        xld-load_definition.json: |
          {
          "users": [
            {
                "name": "{{`{{ .Values.auth.username }}`}}",
                "password": "{{`{{ .Values.auth.password }}`}}",
                "tags": "administrator"
            }
            ],
          "vhosts": [
            {
              "name": "/"
            }
            ],
            "permissions": [
            {
              "user": "{{`{{ .Values.auth.username }}`}}",
              "vhost": "/",
              "configure": ".*",
              "write": ".*",
              "read": ".*"
            }
            ],
          "global_parameters": [
            {
              "name": "cluster_name",
              "value": ""
            }
            ],
          "policies": [
              {
                "name": "ha-all",
                "apply-to": "all",
                "pattern": ".*",
                "vhost": "/",
                "definition": {
                  "ha-mode": "all",
                  "ha-sync-mode": "automatic",
                  "ha-sync-batch-size": 1
                }
              }
            ]
          }
    extraVolumeMounts: []
    extraVolumes: []
    global: {}
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/rabbitmq
      tag: 3.8.12-debian-10-r10
    ingress:
      annotations: {}
      certManager: false
      enabled: false
      hostname: rabbitmq.local
      path: /
      secrets: []
      tls: false
    initContainers: {}
    install: {{ not .UseExistingMQ}}
    ldap:
      enabled: false
      port: '389'
      servers: []
      tls:
        enabled: false
      user_dn_pattern: cn=${username},dc=example,dc=org
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 120
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    loadDefinition:
      enabled: true
      existingSecret: xld-load-definition
    logs: '-'
    memoryHighWatermark:
      enabled: false
      type: relative
      value: 0.4
    metrics:
      enabled: false
      plugins: rabbitmq_prometheus
      podAnnotations:
        prometheus.io/port: '{{ .Values.service.metricsPort }}'
        prometheus.io/scrape: 'true'
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ''
        rules: []
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        honorLabels: false
        interval: 30s
    networkPolicy:
      allowExternal: true
      enabled: false
    nodeAffinityPreset:
      key: ''
      type: ''
      values: []
    nodeSelector: {}
    pdb:
      create: false
      minAvailable: 1
    persistence:
      accessMode: ReadWriteOnce
      enabled: true
      selector: {}
      size: 8Gi
      storageClass: {{ .StorageClass }}
      volumes: null
    plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
    podAffinityPreset: ''
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      fsGroup: 1001
      runAsUser: 1001
    priorityClassName: ''
    rbac:
      create: true
    readinessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    replicaCount: 3
    resources:
      limits: {}
      requests: {}
    service:
      annotations: {}
      distPort: 25672
      distPortName: dist
      epmdPortName: epmd
      externalTrafficPolicy: Cluster
      extraPorts: []
      labels: {}
      managerPort: 15672
      managerPortName: http-stats
      metricsPort: 9419
      metricsPortName: metrics
      port: 5672
      portName: amqp
      tlsPort: 5671
      tlsPortName: amqp-ssl
      type: LoadBalancer
    serviceAccount:
      create: true
    sidecars: {}
    statefulsetLabels: {}
    terminationGracePeriodSeconds: 120
    tolerations: []
    ulimitNofiles: '65536'
    updateStrategyType: RollingUpdate
    volumePermissions:
      enabled: true
      image:
        pullPolicy: Always
        pullSecrets: []
        registry: docker.io
        repository: bitnami/minideb
        tag: buster
      resources:
        limits: {}
        requests: {}
  resources: {}
  satellite:
    Enabled: false
  tolerations: []
  xldLicense: {{ .DeployLic | b64enc }}
